# Описание

Программа вычисляет три ключевые характеристики L1-кэша процессора:

1. Размер кэш-линии (cache line size)
2. Полный объём кэша L1 Data Cache
3. Ассоциативность (количество ways)

---

## Определение размера кэш-линии (cache line size)

В этой версии используется метод, основанный на измерении влияния **ложного совместного использования данных (false sharing)**.

### Принцип

* Несколько потоков одновременно модифицируют элементы массива.
* Если элементы находятся **в одной кэш-линии**, возникает конфликт: линии постоянно перезаписываются между ядрами.
* Если элементы находятся **в разных кэш-линиях**, потоки работают независимо и конфликт минимален.

### Метод

1. Рассматриваются кандидаты размера линии: 16, 32, 64, 128 байт
2. Для каждого кандидата создаются два теста:

   * **naive** — элементы массива размещаются подряд, что может привести к false sharing
   * **aligned** — каждый элемент выравнивается и разносится на `candidate_bytes`, исключая ложное совместное использование
3. Потоки выполняют большое количество записей
4. Сравниваются времена выполнения:
   * Если значение кандидата совпадает с реальным размером линии — разница между naive и aligned максимальна
   * Если кандидат слишком мал или слишком велик — разница уменьшается
5. Выбирается кандидат с наибольшим отношением `naive/aligned`

Идея возникла исходя из обсуждения: https://stackoverflow.com/questions/39680206/understanding-stdhardware-destructive-interference-size-and-stdhardware-cons

---

## Определение объема L1 Data Cache

random pointer chasing по массивам разного размера.

### Принцип

* Пока рабочий массив помещается в кэш L1 — время доступа стабильно и низко.
* Как только размер массива превышает объем L1 — большинство обращений становятся промахами, время резко возрастает.

### Метод

1. Формируются массивы размеров: 1 KB, 2 KB, 4 KB, ..., 512 KB
2. Для каждого:

   * Создается случайный цикл указателей
   * Выполняется большое количество шагов по цепочке указателей
   * Измеряется среднее время доступа
3. По числовым данным виден резкий скачок
4. Объем L1 принимается как последний размер перед резким ростом

---

## Определение ассоциативности L1

Ассоциативность

### Принцип

* Все адреса, попадающие в один и тот же индекс набора, конкурируют за него.
* Если число конфликтующих линий <= associativity — кэш работает быстро.
* Если конфликтов больше — начинается замещение, и время резко возрастает.

### Метод

1. Для каждого `k` от 1 до 16:

   * Строится массив конфликтующих адресов, которые гарантированно попадают в один и тот же cache set:

     * Используется шаг равный размеру L1 — так все адреса соответствуют одному набору
   * Создается случайный цикл указателей только по этим k адресам
   * Измеряется медианное время прохода
2. Пока `k <= associativity`, время почти не меняется
3. Когда `k > associativity`, происходит выход за границу и задержка резко возрастает
4. Значение ассоциативности выбирается как k при первом скачке.

---
